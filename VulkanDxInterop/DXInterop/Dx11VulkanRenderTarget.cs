// ===========================================================================
//                          B I T S   O F   N A T U R E
// ===========================================================================
//  This document contains proprietary information. It is the exclusive
//  confidential property of Stryker Corporation and its affiliates.
//  
//  Copyright (c) 2021 Stryker
// ===========================================================================

using System;
using BitsOfNature.Core;
using BitsOfNature.Core.Utils;
using BitsOfNature.Rendering.Vulkan.Engine;
using BitsOfNature.Rendering.Vulkan.Interop;
using BitsOfNature.Rendering.Vulkan.LowLevel;
using D3D11 = SharpDX.Direct3D11;
using DXGI = SharpDX.DXGI;

namespace BitsOfNature.Rendering.Vulkan.Wpf.DXInterop
{
    /// <summary>
    ///     This class is the DirectX interop rendertarget for dispatching between DX(11) and Vulkan
    ///
    ///     A DirectX texture is generated by a valid DirectX 11 device with
    ///         SharpDX.Direct3D11.ResourceOptionFlags.SharedKeyedmutex
    ///         SharpDX.Direct3D11.ResourceOptionFlags.SharedNthandle
    ///     This kind of texture can be imported into Vulkan by using VkImportMemoryWin32HandleInfoKHR vulkan structure
    ///
    ///     This class provides full Rendertarget class functionality as well as copying vulkan content to an external
    ///     Dx9Ex/Dx11 texture which can be a WPF texture which is created by an DirectX9Ex device with Dx rendertarget capabilities.
    ///     DX9Ex texture must by retrievable by DXGI functionality to return a compatible legacy handle for a copy between a DX11 and DX9Ex device.
    /// </summary>
    public class DxInteropRenderTarget : RenderTarget
    {

        #region Internal Structs
        /// <summary>
        ///     Item to store vulkan image and imageview
        /// </summary>
        private struct VulkanImageItem
        {
            /// <summary>
            ///     Vulkan shared image used for dx to render into, used as external imported resource by DX(11)
            /// </summary>
            public Image sharedImage;
            /// <summary>
            ///     Associated imageview to sharedImage
            /// </summary>
            public ImageView sharedImageViews;
        }

        /// <summary>
        ///     DirectX dispatch/staging texture to support a Vulkan/DX interoptexture which is used by vulkan to render into
        /// </summary>
        private struct DXDispatchItem
        {
            /// <summary>
            ///     Provided and compatible rendering 2D texture, created by DX(11) device
            /// </summary>
            public D3D11.Texture2D texture;
            /// <summary>
            ///     Compatible NT-Shared handle which is used by vulkan to import DX texture
            /// </summary>
            public IntPtr sharedHandle;
        }
        #endregion

        #region Private Attributes
        /// <summary>
        ///     A semaphore to signal rendering is ready to render
        /// </summary>
        private Semaphore _readySemaphore;
        /// <summary>
        ///     A semaphore to signal rendering is completed
        /// </summary>
        private Semaphore _completeSemaphore;

        /// <summary>
        ///     Number of textures, which are used to render into. Can be chained. Currently set to 1, device waits to be finished before dispatched
        /// </summary>
        private const int DispatchTexturesCount = 1;

        /// <summary>
        ///     Associated vulkan image items
        /// </summary>
        private VulkanImageItem[] _vulkanImageItems;

        /// <summary>
        ///     Associated DX image items
        /// </summary>
        private DXDispatchItem[] _dxDispatchItems;

        /// <summary>
        ///     Actual texture index, currently only set to 0, because only one dispatch texture count item is used
        /// </summary>
        private int _actualTextureIndex;
        /// <summary>
        ///     Next current texture index, currently only set to 0, because only one dispatch texture count item is used
        /// </summary>
        private int _newTextureIndex;

        /// <summary>
        ///     Associated Dx9Ex/Dx11 texture with legacy shared handle functionality. Here used to copy content down to wpf surface
        /// </summary>
        private readonly D3D11.Texture2D _wpfTexture;

        /// <summary>
        ///     Current image dimension of surface/resource
        /// </summary>
        private Int2 _imageDimension;

        /// <summary>
        ///     Current vulkan device
        /// </summary>
        private readonly Device _device;
        /// <summary>
        ///     Current rendering context
        /// </summary>
        private readonly RenderingContext _renderContext;

        #endregion

        #region Public Properties

        /// <summary>
        ///     Current rendering context
        /// </summary>
        public RenderingContext RenderingContext => _renderContext;

        #endregion

        #region Construction
        /// <summary>
        ///     Creates specific DirectX/Vulkan interop rendertarget
        /// </summary>
        /// <param name="renderContext">
        ///     Needed associated rendercontext
        /// </param>
        /// <param name="d3dDevice">
        ///     Your valid D3D11 device
        /// </param>
        /// <param name="wpfResource">
        ///     Compatible Sharp.DXGI.Resource, should be a DX9Ex texture declared as rendertarget or a DX11 2D texture with legacy SharedHandle flag
        ///     <see cref="SharpDX.Direct3D11.ResourceOptionFlags.Shared"/>
        /// </param>
        public DxInteropRenderTarget(RenderingContext renderContext, D3D11.Device d3dDevice, DXGI.Resource wpfResource) : base(
            renderContext, 96)
        {
            D3D11.Device2 d3dDevice2 = d3dDevice.QueryInterface<D3D11.Device2>();
            this._wpfTexture = d3dDevice2.OpenSharedResource<D3D11.Texture2D>(wpfResource.SharedHandle);
            this._imageDimension = new Int2(this._wpfTexture.Description.Width, this._wpfTexture.Description.Height);
            this._renderContext = renderContext;
            this._device = renderContext.Device;
            Build(d3dDevice);
        }
        #endregion

        #region Private Methods
        /// <summary>
        ///     Creates a compatible DX11 2D texture with SharedKeyedmutex and SharedNthandle flags
        /// 
        ///     <see cref="SharpDX.Direct3D11.ResourceOptionFlags"/>
        /// </summary>
        /// <param name="d3dDevice">
        ///     Your valid D3D11 device
        /// </param>
        private void CreateDispatchTextures(D3D11.Device d3dDevice)
        {
            if (this._dxDispatchItems == null)
            {
                D3D11.Texture2DDescription textureDesc = new D3D11.Texture2DDescription()
                {
                    Width = _imageDimension.Width,
                    Height = _imageDimension.Height,
                    MipLevels = 1,
                    ArraySize = 1,
                    Format = DXGI.Format.B8G8R8A8_UNorm,
                    SampleDescription = new DXGI.SampleDescription(1, 0),
                    Usage = D3D11.ResourceUsage.Default,
                    OptionFlags = D3D11.ResourceOptionFlags.SharedKeyedmutex | D3D11.ResourceOptionFlags.SharedNthandle,
                    BindFlags = D3D11.BindFlags.ShaderResource,
                    CpuAccessFlags = D3D11.CpuAccessFlags.Write | D3D11.CpuAccessFlags.Read,
                };

                this._dxDispatchItems = new DXDispatchItem[DispatchTexturesCount];
                for (int i = 0; i < _dxDispatchItems.Length; i++)
                {
                    this._dxDispatchItems[i] = new DXDispatchItem();
                    this._dxDispatchItems[i].texture = new D3D11.Texture2D(d3dDevice, textureDesc);
                    using (DXGI.Resource1 resource1 = _dxDispatchItems[i].texture.QueryInterface<DXGI.Resource1>())
                    {
                        this._dxDispatchItems[i].sharedHandle = resource1.CreateSharedHandle(null, DXGI.SharedResourceFlags.Read | DXGI.SharedResourceFlags.Write);
                    }
                }
            }
        }

        /// <summary>
        ///     Build whole structure of rendertarget with
        ///     DX11 2d textures and compatible vulkan images and imageviews
        ///     Memory of image is imported from DX11 2d texture and used as own memory structure, <see cref="VkImportMemoryWin32HandleInfoKHR"/>
        ///     The imported proxy vulkan texture must be compatible in:
        ///         - dimension
        ///         - tiling
        ///         - 2D image type
        ///         - external type must be D3d11Texture, <see cref="VkExternalMemoryHandleTypeFlags"/>
        ///         - format
        ///         - sample(count)
        /// </summary>
        /// <param name="d3dDevice">
        ///     Your valid D3D11 device
        /// </param>
        private unsafe void Build(D3D11.Device d3dDevice)
        {
            CreateDispatchTextures(d3dDevice);

            // --------------------------
            // Image construction
            VkExternalMemoryHandleTypeFlags externalType = VkExternalMemoryHandleTypeFlags.D3D11Texture;
            VkExternalMemoryImageCreateInfo externalMemoryImageCreateInfo = new VkExternalMemoryImageCreateInfo
            {
                HandleTypes = externalType,
            };

            VkImageCreateInfo imageInfo = new VkImageCreateInfo()
            {
                pNext = &externalMemoryImageCreateInfo,
                ImageType = VkImageType._2D,
                Extent = new VkExtent3D(_imageDimension.Width, _imageDimension.Height, 1),
                MipLevels = 1,
                ArrayLayers = 1,
                Format = VkFormat.B8G8R8A8UNorm,
                Tiling = VkImageTiling.Optimal,
                InitialLayout = VkImageLayout.Undefined,
                Usage = VkImageUsageFlags.ColorAttachment | VkImageUsageFlags.TransferSrc,
                SharingMode = VkSharingMode.Exclusive,
                Samples = VkSampleCountFlags._1,
                Flags = 0
            };

            this._vulkanImageItems = new VulkanImageItem[this._dxDispatchItems.Length];
            this._readySemaphore = new Semaphore(_device);
            this._completeSemaphore = new Semaphore(_device);
            for (int i = 0; i < this._vulkanImageItems.Length; i++)
            {
                VkImage image;
                VkResult vkres = this._device.Api.CreateImage(_device.Handle, &imageInfo, null, &image);
                vkres.AssertOk("CreateImage");

                this._vulkanImageItems[i] = new VulkanImageItem();
                this._vulkanImageItems[i].sharedImage = Image.Wrap(_device, image, VkFormat.B8G8R8A8UNorm, _imageDimension, VkSampleCountFlags._1);

                VkImportMemoryWin32HandleInfoKHR importAllocInfo = new VkImportMemoryWin32HandleInfoKHR()
                {
                    HandleType = externalType,
                    Handle = this._dxDispatchItems[i].sharedHandle,
                };
                VkMemoryRequirements requirements;
                this._device.Api.GetImageMemoryRequirements(this._device.Handle, this._vulkanImageItems[i].sharedImage.Handle, &requirements);
                MemoryType memoryType = MemoryType.Find(this._device.Physical, requirements, new[] { VkMemoryPropertyFlags.DeviceLocal });
                VkMemoryAllocateInfo info = new VkMemoryAllocateInfo()
                {
                    pNext = &importAllocInfo,
                    AllocationSize = (uint)requirements.Size,
                    MemoryTypeIndex = (uint)memoryType.Index,
                };
                VkDeviceMemory memoryHandle;
                vkres = this._device.Api.AllocateMemory(_device.Handle, &info, null, &memoryHandle);
                vkres.AssertOk("AllocateMemory");

                vkres = this._device.Api.BindImageMemory(_device.Handle, image, memoryHandle, 0);
                vkres.AssertOk("BindMemory");

                this._vulkanImageItems[i].sharedImageViews = new ImageView(_device, this._vulkanImageItems[i].sharedImage, this._vulkanImageItems[i].sharedImage.Format, VkImageAspectFlags.Color);
            }
        }
        
        /// <summary>
        ///     Renders result by acquiring DX11 2d rendertexture used from vulkan and copying its content to external (WPF) DX9ex/DX11 texture  
        /// </summary>
        /// <returns>
        ///     true, if operation was successful
        /// </returns>
        private void RenderResult()
        {
            using (DXGI.KeyedMutex dxgiMutex = this._dxDispatchItems[this._actualTextureIndex].texture.QueryInterface<DXGI.KeyedMutex>())
            {
#pragma warning disable S125 // Sections of code should not be commented out
                // This makes currently not any sense in this scenario, so using only ID 0 for AcquireSync/ReleaseSync:
                // AcquireSync and ReleaseSyncs behaves in same way like a non recursive mutex.
                // Since Windows8 D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX is recommended instead of using D3D11_RESOURCE_MISC_SHARED (they are mutually exclusive)
                // Operation is needed to "chain" different threads in this way to make it a little bit clearer:
                //
                // Within Device 1's process/thread:
                // Rendering onto Sync Shared Resource from D3D10.1 Device 1 using D3D10.1 Device 1

                //      result = DXGIKeyedMutexDevice1.AcquireSync(0, timeOut);
                // Rendering calls using Device 1
                //      ...
                //      result = DXGIKeyedMutexDevice1.ReleaseSync(1);
                //      ...
                ////////////////////////////////////////////////////////////////////////////
                // Within Device 2's process/thread:
                // Rendering onto Sync Shared Resource from D3D10.1 Device 1 using D3D10.1 Device 2
                //      result = DXGIKeyedMutexDevice2.AcquireSync(1, timeOut);
                // Rendering calls using Device 2
                //      ...
                //      result = DXGIKeyedMutexDevice1.ReleaseSync(2);
                ////////////////////////////////////////////////////////////////////////////
                // Within Device 3's process/thread:
                // Rendering onto Sync Shared Resource from D3D10.1 Device 1 using D3D10.1 Device 3
                //      result = DXGIKeyedMutexDevice1.AcquireSync(2, timeOut);
                // Rendering calls using Device 3
                //      ...
                //      result = DXGIKeyedMutexDevice.ReleaseSync(0);
                //      ...
#pragma warning restore S125 // Sections of code should not be commented out

                if (dxgiMutex != null)
                {
                    SharpDX.Result hr = dxgiMutex.Acquire(0, -1);
                    Assert.That(hr.Success, "dxgiMutex.AcquireSync has failed!");
                    if (!hr.Success)
                    {
                        // Should never happen in this scenario!
                        return;
                    }
                }

                // Note: Must wait! needed to have the correct current frame and no other synchronisation mechanism is available between Vulkan and DX(11)
                _renderContext.Device.WaitIdle();
                InstanceBuilder.DX11Device.ImmediateContext.CopyResource(_dxDispatchItems[this._actualTextureIndex].texture, _wpfTexture);

                if (dxgiMutex != null)
                {
                    dxgiMutex.Release(0);
                }
            }
        }
       #endregion
        
        #region RenderTarget Overrides
        
        /// <summary>
        ///     <inheritdoc/>
        /// </summary>
        public override Int2 Size => _imageDimension;
        
        /// <summary>
        ///     <inheritdoc/>
        /// </summary>
        protected override FrameData BeginImpl()
        {
            this._actualTextureIndex = this._newTextureIndex;
            this._newTextureIndex++;
            this._newTextureIndex %= this._vulkanImageItems.Length;
            return new FrameData(this._vulkanImageItems[_newTextureIndex].sharedImageViews,
                VkImageLayout.ColorAttachmentOptimal, this._readySemaphore, this._completeSemaphore);
        }

        /// <summary>
        ///     <inheritdoc/>
        /// </summary>
        protected override void EndImpl()
        {
            RenderResult();
        }
        #endregion
        
        #region IDisposable Members
        /// <summary>
        ///     Must be implemented, disposable
        /// </summary>
        protected override void DisposeImpl()
        {
            if (this._dxDispatchItems != null)
            {
                for (int i = 0; i < this._dxDispatchItems.Length; i++)
                {
                    CommonUtils.DisposeAndSetNull(ref _dxDispatchItems[i].texture);
                }
                this._dxDispatchItems = null;
            }
        }
        #endregion


    }
}
